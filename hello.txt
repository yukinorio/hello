import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.reactive.function.client.WebClient;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class MyClassTest {

    @Test
    void test404Error() {
        try (MockedStatic<MyClass> myClassMockedStatic = Mockito.mockStatic(MyClass.class)) {

            WebClient.RequestHeadersSpec requestHeadersSpecMock = mock(WebClient.RequestHeadersSpec.class);
            WebClient.RequestHeadersUriSpec requestHeadersUriSpecMock = mock(WebClient.RequestHeadersUriSpec.class);
            WebClient webClientMock = mock(WebClient.class);
            ClientResponse clientResponseMock = mock(ClientResponse.class);

            when(webClientMock.get()).thenReturn(requestHeadersUriSpecMock);
            when(requestHeadersUriSpecMock.uri(any(String.class))).thenReturn(requestHeadersSpecMock);
            when(requestHeadersSpecMock.exchangeToMono(any())).thenAnswer(invocation -> {
                Function<ClientResponse, Mono<Void>> function = invocation.getArgument(0);
                function.apply(clientResponseMock);
                return Mono.empty();
            });
            when(clientResponseMock.statusCode()).thenReturn(HttpStatus.NOT_FOUND);

            // Assume MyClass.request() uses WebClient.builder().build() internally
            myClassMockedStatic.when(() -> MyClass.request(anyString())).thenCallRealMethod();
            try (MockedStatic<WebClient> webClientMockedStatic = Mockito.mockStatic(WebClient.class)) {
                webClientMockedStatic.when(WebClient::builder).thenReturn(mock(WebClient.Builder.class));
                when(WebClient.builder().build()).thenReturn(webClientMock);

                MyClass.request("http://localhost:8080");  // Calls the real method, but with mocked WebClient
            }
        }
    }
}
